\documentclass{article}
% Encodage et langue
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

% Mathématiques
\usepackage{amsmath, amssymb}

% Mise en page
\usepackage[a4paper, height=22cm, width=13.5cm]{geometry}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{array}
\usepackage{makecell}
\usepackage{float}
% Graphiques et dessins
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{backgrounds}

% Encadrés et couleurs
\usepackage{xcolor}
\usepackage{tcolorbox}

% Algorithmes
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

% Listings (code source)
\usepackage{listings}

% En-têtes/pieds de page
\usepackage{fancyhdr}
\usepackage{lastpage}

% Hyperliens
\usepackage[colorlinks=true, linkcolor=black, citecolor=black, urlcolor=black]{hyperref}


% Pour arrière-plan avec TikZ
\usepackage{eso-pic}

\usepackage{graphicx}

\begin{document}

% Première page : uniquement l'arrière-plan
\AddToShipoutPictureBG*{%
  \begin{tikzpicture}[remember picture, overlay]
    \node[opacity=1, inner sep=0pt] at (current page.center) {
      \includegraphics[width=\paperwidth,height=\paperheight]{img/poster.png}};
  \end{tikzpicture}}
\null  % Page vide avec l'arrière-plan
\thispagestyle{empty}
\newpage

% Deuxième page : page de titre
\begin{titlepage}
\begin{center}

% Logos en haut
\vspace*{0.5cm}
\begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[width=0.4\linewidth]{img/enseirb.png}
\end{minipage}%
\hfill
\begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[width=0.4\linewidth]{img/logo.png}
\end{minipage}

\vspace{1.5cm}

% Titre
\rule{\textwidth}{1pt}
\vspace{0.6cm}

{\Huge \textbf{Entraînement à la programmation}}\\[0.4cm]
{\Large Cahier des charges du PFA}

\vspace{0.6cm}
\rule{\textwidth}{1pt}

\vspace{2cm}

% Auteurs
{\large \textbf{Auteurs}}\\[0.3cm]
{\normalsize
Romain \textsc{GUENINCHAULT} \\
Toine \textsc{HORNY} \\
Youness \textsc{BAMOUSS} \\
Mohamed Amine \textsc{BENKADUR} \\
Arthur \textsc{PIERRE}}\\[1cm]

% Encadrant
{\large \textbf{Encadrant}}\\[0.3cm]
{\normalsize Julien \textsc{ALLALI}}

\vfill

% Informations complémentaires
{\large Département Informatique\\
ENSEIRB-MATMECA -- Bordeaux INP\\[0.3cm]
Année universitaire 2025--2026}

\end{center}
\end{titlepage}

% Table des matières
\tableofcontents
\newpage

\section{Introduction}

L’objectif de ce projet est de développer un système permettant à l’utilisateur de s’entraîner à la programmation directement sur son environnement. Il proposera des exercices progressifs et interactifs, avec des retours sur les solutions afin de faciliter l’apprentissage et le suivi des progrès.

\section{Problématique}

L’entraînement à la programmation représente aujourd’hui une difficulté importante, en particulier pour les étudiants. La méthode la plus courante consiste à écrire une solution, la compiler, puis vérifier manuellement son fonctionnement en exécutant quelques tests préparés à l’avance. Cette approche est souvent longue, répétitive et source d’erreurs, notamment lorsqu’il faut imaginer soi-même des cas de test pertinents et interpréter les résultats sans retour clair sur les points à améliorer.


\section{Objectif du projet}

\subsection{Objectifs primaires}

Le but de notre système est de proposer un environnement de travail à un utilisateur afin que celui-ci puisse réaliser des exercices contenus dans un dépôt git choisi par ses soins. Le système devra pouvoir s'adapter à n'importe quelle structure de dépôt, bien que les dépôts doivent répondre à quelques critères spécifiques notamment sur le contenu des fichiers \textit{.yaml}.

\subsection{Objectifs secondaires}

Le système analysera le temps nécessaire à l’utilisateur pour implémenter sa solution et collectera des informations sur son niveau de progression. À partir de ces données, il pourra ensuite proposer automatiquement des exercices adaptés à son profil, afin d’assurer un apprentissage progressif et personnalisé.

\subsection{Hors périmètre}

L’utilisateur aura librement accès aux outils d’IA et à la documentation disponible sur Internet. Le système n’a pas vocation à reproduire des conditions d’examen : il ne cherchera donc pas à détecter une éventuelle « triche », et l’apprentissage reposera principalement sur la bonne foi et la motivation de l'utilisateur.

\section{Fonctionnalités attendues}

Le système a pour objectif de fournir un environnement complet permettant à un utilisateur de s'entraîner à la programmation de manière autonome et progressive. Il repose sur une interface en ligne de commande offrant un ensemble de fonctionnalités destinées à faciliter la consultation, la résolution et l'évaluation d'exercices de programmation.

L'utilisateur peut consulter la liste des exercices disponibles à tout moment. Cette liste présente les informations essentielles telles que le nom de l'exercice, le langage utilisé et le niveau de difficulté estimé. L'affichage est conçu pour rester lisible, même en présence d'un grand nombre d'exercices, grâce à une organisation en colonnes structurée, à l'utilisation de couleurs pour faciliter la lecture et, si nécessaire, à des mécanismes de filtrage par difficulté, thème ou langage. Une pagination peut également être mise en place pour éviter la saturation visuelle.

Le système permet l'installation et la gestion locale d'une base d'exercices. Une fois installée, cette base peut être exploitée sans dépendre d'une infrastructure distante. L'utilisateur peut sélectionner un exercice et l'ajouter à un répertoire de travail personnel, distinct du dépôt d'origine, afin de préserver l'intégrité de la base d'exercices. Le système vérifie alors que l'environnement de travail est valide et prêt à être utilisé.

Une fois l'exercice ajouté, l'utilisateur peut compiler son code directement depuis l'outil. La compilation utilise les paramètres définis dans les métadonnées de l'exercice et affiche de manière claire les erreurs et avertissements éventuels. Lorsque la compilation réussit, le système permet l'exécution automatique des tests associés à l'exercice.

Les tests sont exécutés localement et comparent la sortie du programme de l'utilisateur avec les résultats attendus ou avec une solution de référence. Le système fournit un retour détaillé indiquant les tests réussis et échoués, ainsi qu'un résumé global permettant de déterminer si l'exercice est validé. En cas d'échec, les différences entre les sorties sont présentées de manière explicite afin d'aider l'utilisateur à comprendre ses erreurs.

Le système mesure le temps de résolution d'un exercice, depuis son ajout au répertoire de travail jusqu'à la validation complète des tests. Ces informations sont enregistrées localement de manière fiable et peuvent être consultées ultérieurement afin de permettre à l'utilisateur de suivre sa progression. À terme, ces données pourront servir de base à un système de recommandation d'exercices adaptés, proposant des défis en fonction du niveau estimé de l'utilisateur, de sa progression, de ses taux de réussite et des difficultés rencontrées.



\section{Contraintes}

\subsection{Contraintes fonctionnelles}

Les exercices doivent être résolus et évalués localement sur la machine de l'utilisateur. Le système ne repose pas sur une infrastructure distante obligatoire pour la compilation ou l'exécution des programmes, afin de garantir son autonomie et sa portabilité.

D'un point de vue système, la base d'exercice doit contenir les informations nécessaires pour pouvoir installer, compiler et tester un exercice sur la machine de l'utilisateur. Le système ne requiert pas de compilateur ou de manière d’exécuter les tests particuliers ; il doit pouvoir s'adapter à la façon dont les personnes écrivant les exercices veulent faire compiler et exécuter ceux-ci.

Le système gère un répertoire de travail isolé pour l'utilisateur. Les fichiers du dépôt d'exercices ne sont jamais modifiés directement, ce qui permet de réinitialiser un exercice ou d'en recommencer un autre sans altérer la base initiale.

Lors de l'exécution des tests, le système fournit un retour clair et exploitable. Les résultats indiquent explicitement si un test a réussi ou échoué.

Le temps de résolution des exercices doit être mesuré de manière cohérente et fiable. Le système enregistre le moment où l'utilisateur commence à travailler sur un exercice et celui où il le valide complètement, permettant ainsi un suivi précis de la progression et servant de base à d'éventuelles recommandations personnalisées.

\subsection{Contraintes non fonctionnelles}

Le système doit fonctionner sur un environnement Linux standard. Une compatibilité avec d'autres systèmes d'exploitation pourra être envisagée ultérieurement, en fonction du temps et des ressources disponibles.

L'installation et l'utilisation de l'outil doivent rester simples. L'objectif est de permettre à un utilisateur de commencer à s'entraîner rapidement, à l'aide d'une installation minimale et d'une interface en ligne de commande intuitive.

Le système doit être robuste face aux erreurs courantes, telles que les erreurs de compilation, les fichiers manquants ou les mauvaises configurations. Les messages d'erreur doivent être explicites et permettre à l'utilisateur de comprendre rapidement l'origine du problème.

Les performances doivent rester suffisantes pour garantir une utilisation fluide. Les tests simples doivent produire un retour rapide, permettant à l'utilisateur d'enchaîner les itérations sans latence excessive.

Les retours fournis à l'utilisateur doivent être lisibles et bien structurés. L'utilisation de couleurs pour différencier les succès et les échecs, ainsi que des résumés synthétiques et des détails optionnels consultables à la demande, permet de rendre l'information exploitable sans surcharge visuelle.

Enfin, l'architecture globale du système doit être pensée de manière extensible, afin de faciliter l'ajout de nouveaux exercices, de nouveaux tests ou de nouvelles fonctionnalités sans nécessiter une refonte complète.


\section{Organisation des exercices}

Les dépôts d'exercices auront une configuration minimale requise pour pouvoir fonctionner avec le système. Ils pourront contenir différents fichiers \textit{.yaml} contenant les métadonnées nécessaires au fonctionnement d'un exercice. Ces fichiers \textit{.yaml} seront lus récursivement et les informations les plus hautes seront supprimées au profit des données les plus basses si réécrites.

\subsection{Métadonnées attendues}

\begin{itemize}
\item  author
\item  langage
\item  module				
\item  description		\# Description affichée lors du ls
\item  tags			    \#Tags pour décrire un exercice ( difficulté, type...)
\item  timeout		    \#Duree en minute pour resoudre l'exercice
\item  distributes:		\# Fichiers copiés dans le répertoire de l'utilisateur
\item  commands:		
\item  prepare 	        \#Executé lors de l'installation de l'exercice
\item  validate 	    \#Compilation(optionelle)+Execution + Test
\item	clean 		    \#Executé lorsque l'utilisateur quitte
\item
\end{itemize}

\section{Livrables}

Le projet donnera lieu à la production des éléments suivants, organisés selon les phases de développement prévues.

\subsection{Livrables techniques}

\subsubsection{Code source et exécutables}

Le système sera livré sous la forme d'un outil en ligne de commande fonctionnel, accompagné de l'ensemble de son code source. L'application devra être installable via un script ou une commande simple, et utilisable immédiatement après installation sur un environnement Linux standard.

Le code source comprendra l'ensemble des modules nécessaires au fonctionnement du système : gestion des exercices, mesure du temps, affichage des résultats.

\subsubsection{Base d'exercices}

Une base d'exercices sera fournie, donnant un exemple aux personnes voulant écrire des exercices de manière simple comme compliquée. Elle présentera un exemple d'architecture des fichiers \textit{.yaml} ainsi que différentes manière de compiler des exercices et d'exécuter des tests.

\subsection{Documentation}

\subsubsection{Documentation utilisateur}

Un guide complet destiné aux utilisateurs finaux (étudiants) sera fourni. Ce guide comprendra :

\begin{itemize}
    \item Un tutoriel de démarrage rapide expliquant l'installation et la première utilisation ;
    \item Une description détaillée de toutes les commandes disponibles avec leur syntaxe et des exemples d'utilisation ;
    \item Une section FAQ répondant aux problèmes courants ;
\end{itemize}

\subsubsection{Documentation technique}

Une documentation technique sera produite à destination des développeurs et des créateurs d'exercices. Elle contiendra :

\begin{itemize}
    \item L'architecture globale du système et l'explication des différents modules ;
    \item Le format complet du fichier YAML de métadonnées avec tous les champs disponibles ;
    \item Un guide de création d'exercices avec des templates et des exemples commentés ;
\end{itemize}

\section{Critères de validation}

Le projet sera considéré comme validé si l'ensemble des critères suivants sont satisfaits. Ces critères sont organisés par niveau de priorité selon la classification MoSCoW (Must have, Should have, Could have).

\subsection{Critères obligatoires (Must have)}

\subsubsection{Installation et configuration}

Le système doit pouvoir être installé sur une machine Linux standard via pip. L'installation doit créer correctement l'ensemble de la structure de répertoires nécessaire et vérifier la présence des dépendances requises. Un message de confirmation doit indiquer le succès de l'installation.

\subsubsection{Installation d'une base d'exercices}

Le système doit permettre à l'utilisateur d'ajouter une base d'exercice à son répertoire de travail à partir de son URL de dépôt. Il doit aussi permettre à l'utilisateur de mettre àjour cette base d'exercice à n'importe quel moment.

\subsubsection{Consultation des exercices}

L'utilisateur doit pouvoir afficher la liste complète des exercices disponibles via une commande simple. L'affichage doit présenter de manière lisible et structurée les informations essentielles : nom de l'exercice, langage de programmation, niveau de difficulté estimé. L'organisation en colonnes et l'utilisation de couleurs doivent faciliter la lecture, même en présence d'un grand nombre d'exercices.

Si la liste est trop longue, un système de pagination doit être mis en place pour éviter la saturation de l'affichage terminal. L'utilisateur doit également pouvoir accéder à une aide détaillant toutes les commandes disponibles avec leur syntaxe et des exemples d'utilisation.

\subsubsection{Installation d'un exercice}

Cette opération doit copier tous les fichiers nécessaires (énoncé, fichiers sources, métadonnées) sans modifier le dépôt d'exercices d'origine.

Le système doit vérifier que le répertoire de destination est vide avant d'y copier l'exercice et afficher un message d'erreur clair dans le cas contraire. Une fois l'exercice copié, les tests doivent être automatiquement compilés et le code source de la solution de référence doit être supprimé pour éviter toute tentation de consultation prématurée.

L'utilisateur doit pouvoir nettoyer son répertoire de travail via une commande dédiée. Cette commande doit demander une confirmation avant de supprimer les fichiers et ne doit affecter que le répertoire de travail, en préservant tous les autres fichiers du système.

\subsubsection{Compilation et exécution}

Le système doit pouvoir utiliser les commandes de configuration du fichier \textit{.yaml} pour pouvoir compiler, exécuter et tester un exercice.

\subsubsection{Suppression du répertoire de travail}

Le système doit pouvoir supprimer le répertoire de travail tout en faisant attention à ne pas supprimer des données de l'utilisateur.

\subsection{Critères importants (Should have)}

\subsubsection{Gestion du timeout}

Le système doit pouvoir utiliser temps de résolution recommandé, défini dans les métadonnées de chaque exercice. Si ce temps est dépassé, un avertissement doit être affiché à l'utilisateur pour l'informer qu'il dépasse le temps attendu, sans pour autant bloquer sa progression. Ce mécanisme sert de point de repère pédagogique.

\subsubsection{Gestion robuste des erreurs}

Le système doit gérer de manière robuste l'ensemble des erreurs courantes : fichier manquant, mauvaise configuration, erreur de compilation, erreur d'exécution, format de métadonnées invalide.

Chaque erreur doit être accompagnée d'un message clair et explicite permettant à l'utilisateur de comprendre rapidement la nature du problème. Un mode verbeux doit être disponible pour afficher des traces détaillées en cas de besoin. Les erreurs ne doivent en aucun cas causer un plantage du système.

\subsection{Critères souhaitables (Could have)}

\subsubsection{Filtrage et recherche d'exercices}

Le système doit permettre de filtrer les exercices selon différents critères : niveau de difficulté, thème abordé (récursion, pointeurs, structures de données, etc.), langage de programmation.

Les tags doivent être définis dans les métadonnées des exercices et validés par rapport à un schéma centralisé garantissant leur cohérence. Une commande doit permettre de lister tous les tags disponibles et une autre de rechercher des exercices selon plusieurs critères combinés.

\subsubsection{Recommandation d'exercices}

À partir des données de temps de résolution et de taux de réussite enregistrées, le système peut proposer des exercices adaptés au niveau estimé de l'utilisateur.

Ce système de recommandation peut se baser sur des heuristiques simples (progression linéaire de difficulté) ou sur des algorithmes plus sophistiqués tenant compte des performances passées de l'utilisateur sur différents types d'exercices.

\subsection{Critères de qualité transverses}

\subsubsection{Portabilité}

Le système doit fonctionner sur toute distribution Linux récente disposant des outils de compilation standard (gcc ou clang pour le C). Les dépendances externes doivent être minimales et clairement documentées.

Une compatibilité avec macOS et Windows pourra être envisagée en fonction du temps disponible, mais n'est pas requise pour la validation du projet.

\subsubsection{Lisibilité des sorties}

Tous les messages affichés à l'utilisateur doivent être clairs, structurés et exploitables. L'utilisation de couleurs doit permettre de distinguer rapidement les succès des échecs. Les informations détaillées doivent être disponibles sur demande mais ne pas encombrer l'affichage par défaut.

Les résultats de tests doivent être présentés de manière synthétique avec possibilité d'afficher les détails des échecs pour faciliter le débogage.

\section{Approche et méthodologie}
Le développement suivra la méthode agile, centrée sur des livrables fonctionnels utilisables dès les premières itérations. Chaque incrément correspond à un ensemble cohérent de user stories et se termine par une phase de validation (les tests).

La priorisation :
\begin{itemize}
    \item \textbf{Priorité Haute} : base opérationnelle (installation, listing, ajout, compilation, exécution de tests simples, gestion d'erreurs).
    \item \textbf{Priorité Moyenne} : timeouts complets, statistiques, intégration Grader, usage de LLM, ...
    \item \textbf{Priorité Basse} : extension Java, version web, ...
\end{itemize}

\section{Risques et limites}

\subsection{Risques techniques}

\begin{itemize}
    \item \textbf{Complexité de création d'exercices} (structure, métadonnées, tests) : Si la procédure de création d'un exercice est jugée trop complexe ou contraignante, les utilisateurs risquent de préférer ne pas utiliser le système et de travailler en dehors de celui-ci.
    \item \textbf{Exécution de code utilisateur} (programmes trop lents, consommation CPU/mémoire) : Risque de blocage du système : arrêt forcé du processus.
    \item \textbf{Compilation} (gcc, versions différentes, flags, dépendances) : Erreurs non reproductibles selon les machines : dépendances minimales, vérification à l'installation, messages d'erreur clairs.
    \item \textbf{Métadonnées YAML incorrectes} (champs manquants, format invalide) : Crash ou comportement incohérent : validation au chargement + valeurs par défaut + commande \texttt{trainer validate}.
    \item \textbf{Tests non fiables} (cas limites oubliés, sorties dépendantes de l'environnement) : Faux positifs/faux négatifs : base de tests minimale au début, puis automatisation, reproductibilité (seed) pour Grader.
    \item \textbf{Gestion Git} (dépôt indisponible, conflit, mise à jour cassée) : Base non installable : commandes robustes, messages de récupération, versionnement/release du dépôt d'exercices.
\end{itemize}

\subsection{Limites (hors périmètre ou acceptées)}

\begin{itemize}
    \item Pas d'objectif anti-triche : l'utilisateur peut utiliser Internet/IA, le système reste un outil d'entraînement.
    \item Sécurité non garantie à 100 \% : exécution locale, pas de sandbox complète, seulement des protections minimales (timeout, isolation workspace).
    \item Support multi-OS non prioritaire : Linux standard ciblé, extension possible plus tard.
    \item Recommandations avancées par LLM : optionnel, dépend des performances et du temps restant, au mieux POC.
    \item Support Java + interface web : optionnel/facultatif, dépend du temps restant après stabilisation du cœur du système.
\end{itemize}


\end{document}
